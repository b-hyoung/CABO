 2. '커밋왕' 같은 랭킹 기능 구현 아이디어

  '커밋왕' 기능은 사용자들의 재미와 경쟁심을 유발하는 아주 좋은 기능입니다. 직접 구현하려면 백엔드(서버)와
  데이터베이스가 필요하며, 전체적인 흐름은 다음과 같습니다.

  `GitHub API` → `백엔드 서버` → `데이터베이스` → `API` → `프론트엔드`

  구현 단계별 아이디어

  1단계: 데이터 수집 (GitHub API 연동)

   * 먼저 특정 사용자의 커밋 기록을 가져와야 합니다. GitHub API의 [Events
    API](https://docs.github.com/en/rest/activity/events)를 사용하면 사용자의 활동 기록(PushEvent, 즉 커밋)을 가져올 수 있습니다.
   * 백엔드 서버(예: Python FastAPI)에서 이 API를 호출하여 지난 일주일 또는 한 달간의 커밋 데이터를 수집합니다.
   * 주의할 점: GitHub API는 시간당 요청 횟수가 정해져 있으므로, 너무 자주 호출하지 않도록 주의해야 합니다.

  2단계: 데이터 저장 (데이터베이스 설계)

   * 매번 랭킹을 보여줄 때마다 GitHub API를 호출하는 것은 매우 느리고 비효율적입니다. 따라서 수집한 데이터를 자체
     데이터베이스(DB)에 저장해야 합니다.
   * Users 테이블 외에, DailyCommits 같은 테이블을 만들어 사용자별로 매일의 커밋 횟수를 저장해두는 것이 좋습니다.
       * 예: (user_id, date, commit_count)

  3단계: 랭킹 집계 (스케줄링 작업)

   * '커밋왕' 랭킹을 실시간으로 계산하는 것은 서버에 부담을 줍니다. 대신 하루에 한 번 등 정해진 시간에 미리 순위를
     계산해두는 것이 좋습니다.
   * 이것을 스케줄링 작업(Scheduled Job 또는 Cron Job) 이라고 부릅니다.
   * 이 작업은 매일 자정에 실행되면서, 데이터베이스에 저장된 커밋 기록을 바탕으로 '최근 7일간 가장 커밋을 많이 한 사용자
     TOP 100'을 계산하여 WeeklyRanking 같은 별도의 테이블에 저장합니다.

  4단계: 랭킹 보여주기 (API 제공)

   * 이제 프론트엔드(현재의 Next.js 페이지)에서는 랭킹을 보여달라고 요청만 하면 됩니다.
   * 백엔드에서는 미리 계산해 둔 WeeklyRanking 테이블에서 순위를 가져와 즉시 전달해줍니다.
   * 이렇게 하면 사용자는 기다림 없이 매우 빠르게 '커밋왕' 랭킹 보드를 볼 수 있습니다.

  요약

  '커밋왕' 기능의 핵심은 "데이터를 미리 수집하고, 정해진 시간에 미리 계산해서, 요청 시에는 계산된 결과만 빠르게 보여주는
  것" 입니다. 이 구조를 이해하시면 '코드 품질왕', '리뷰왕' 등 다양한 랭킹 시스템을 확장해서 만드실 수 있습니다.